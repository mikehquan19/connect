package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"

	"github.com/mikehquan19/connect/graph/model"
	"github.com/mikehquan19/connect/schema"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// Artwork returns ArtworkResolver implementation.
func (r *Resolver) Artwork() ArtworkResolver { return &artworkResolver{r} }

// Chapter returns ChapterResolver implementation.
func (r *Resolver) Chapter() ChapterResolver { return &chapterResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type artworkResolver struct{ *Resolver }
type chapterResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// Users is the resolver for the users field.
// Query the list of users
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	// Query the list of artists (ruling out the users)
	cursor, err := r.DB.Collection("users").Find(context.TODO(), bson.M{
		"role": "ARTIST",
	})
	if err != nil {
		return nil, err
	}

	// Unmarshal the slice of datbase users from the database
	var dbUsers []schema.User
	if err = cursor.All(context.TODO(), &dbUsers); err != nil {
		return nil, err
	}

	// Transform DB users to the GraphQL Users
	// If the client requests the artworks, then user resolver will handle that
	var gqlUsers []*model.User
	for _, dbUser := range dbUsers {
		gqlUsers = append(gqlUsers, transformUser(dbUser))
	}
	return gqlUsers, nil
}

// Artworks is the resolver for the artworks field.
// Query the list of artworks embedded in the author
func (r *userResolver) Artworks(ctx context.Context, user *model.User) ([]*model.Artwork, error) {
	convertedID, err := primitive.ObjectIDFromHex(user.ID)
	if err != nil {
		return nil, err
	}
	// Checkout the latest work of the authors
	cursor, err := r.DB.Collection("artworks").Find(
		context.TODO(),
		bson.M{"author": convertedID},
		options.Find().SetSort(bson.D{{Key: "updatedAt", Value: -1}}),
	)
	if err != nil {
		return nil, err
	}

	// Unmarshal the Mongo data directly to GraphQL
	artworks, err := unmarshalArtworks(cursor)
	return artworks, err
}

// Artworks is the resolver for the artworks field.
// Query the list of latest artworks
func (r *queryResolver) Artworks(ctx context.Context) ([]*model.Artwork, error) {
	// Sort by the last updated date and then created date
	cursor, err := r.DB.Collection("artworks").Find(
		context.TODO(),
		bson.M{},
		options.Find().SetSort(bson.D{
			{Key: "updatedAt", Value: -1},
			{Key: "createdAt", Value: -1},
		}),
	)
	if err != nil {
		return nil, err
	}

	artworks, err := unmarshalArtworks(cursor)
	return artworks, err
}

// Artwork is the resolver for the artwork field.
// Query a single artwork
func (r *queryResolver) Artwork(ctx context.Context, id string) (*model.Artwork, error) {
	artworkID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	var artwork schema.Artwork
	err = r.DB.Collection("artworks").FindOne(
		context.TODO(), bson.M{"_id": artworkID}).Decode(&artwork)
	if err != nil {
		return nil, err
	}

	return transformArtwork(artwork), nil
}

// Author is the resolver for the author field.
// Query the author embedded in the artwork
func (r *artworkResolver) Author(ctx context.Context, work *model.Artwork) (*model.User, error) {
	authorId, err := primitive.ObjectIDFromHex(work.Author.ID)
	if err != nil {
		return nil, err
	}

	var author schema.User
	err = r.DB.Collection("users").FindOne(
		context.TODO(), bson.M{"_id": authorId}).Decode(&author)
	if err != nil {
		return nil, err
	}

	return transformUser(author), nil
}

// Chapters is the resolver for the chapters field.
// Query the list of chapters of the artwork
func (r *artworkResolver) Chapters(ctx context.Context, work *model.Artwork) ([]*model.Chapter, error) {
	convertedID, err := primitive.ObjectIDFromHex(work.ID)
	if err != nil {
		return nil, err
	}
	// Sort by the created date (so that we got 1 -> 2 -> 3)
	cursor, err := r.DB.Collection("chapters").Find(
		context.TODO(),
		bson.M{"artWork": convertedID},
		options.Find().SetSort(bson.D{{Key: "createdAt", Value: 1}}),
	)
	if err != nil {
		return nil, err
	}

	chapters, err := unmarshalChapters(cursor)
	return chapters, err
}

// Chapter is the resolver for the chapter field.
// Query a single chapter
func (r *queryResolver) Chapter(ctx context.Context, id string) (*model.Chapter, error) {
	chapID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	var chap schema.Chapter
	err = r.DB.Collection("chapters").FindOne(
		context.TODO(), bson.M{"_id": chapID}).Decode(&chap)
	if err != nil {
		return nil, err
	}

	return TransformChapter(chap), nil
}

// Query the artwork of the chapter
func (r *chapterResolver) Artwork(ctx context.Context, chap *model.Chapter) (*model.Artwork, error) {
	return nil, nil
}
